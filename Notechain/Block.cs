using System.Diagnostics;
using System.Numerics;
using System.Security.Cryptography;
using System.Text;

namespace Notechain
{
    /// <summary>
    /// Repsesents block in chain that contains data.
    /// </summary>
    public class Block
    {
        /// <summary>
        /// Unique block ID.
        /// </summary>
        public Guid Id { get; set; }

        /// <summary>
        /// Block position in chain (genesis block is 0).
        /// </summary>
        public uint Height { get; set; }

        /// <summary>
        /// Block primary data.
        /// </summary>
        public byte[] Data { get; set; }

        /// <summary>
        /// Block additional string data.
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Block hash.
        /// </summary>
        public byte[] Hash { get; set; }

        /// <summary>
        /// Previous block in chain;
        /// returns <see langword="null"></see>, if current block is a genesis block.
        /// </summary>
        public Block? Previous { get; set; }

        /// <summary>
        /// Local-time timestamp.
        /// </summary>
        public DateTime Timestamp { get; set; }

        /// <summary>
        /// Nonce value that need to be changed to produce new hash.
        /// </summary>
        public ulong Nonce { get; set; }

        /// <summary>
        /// Returns data as decoded UTF-8 string.
        /// </summary>
        public string TextData => Encoding.UTF8.GetString(Data);

        /// <summary>
        /// Returns <see langword="true"></see> if <see cref="Height"/> is zero.
        /// </summary>
        public bool IsGenesis => Height == 0;

        /// <summary>
        /// Verifies the integrity of the block by recalculating its hash and comparing it to the stored hash.
        /// </summary>
        /// <returns><see langword="true"></see> if the block's hash is valid and matches the computed hash; otherwise, <see langword="false"></see>.</returns>
        public bool IsValid => CheckForValidity();

        /// <summary>
        /// Determines block generation rate recalculation interval in hashing iterations.
        /// </summary>
        private static readonly ulong rateCalculationInterval = 200_000;

        public Block(Guid id, uint height, byte[] data, string comment, byte[] hash, DateTime timestamp, ulong nonce)
        {
            Id = id;
            Height = height;
            Data = data;
            Comment = comment;
            Hash = hash;
            Timestamp = timestamp;
            Nonce = nonce;
        }

        /// <summary>
        /// Asynchronously generates a new block with the specified data and comment,
        /// performing a proof-of-work hash calculation to ensure the block's validity.
        /// </summary>
        /// <param name="entry">The data to be stored in the block.</param>
        /// <param name="previousBlock">The previous block in the chain, or <see langword="null"></see> if this is the genesis block.</param>
        /// <returns>A new generated <see cref="Block"/>.</returns>
        public static Block? GenerateNew(Entry entry, Block? previousBlock)
        {
            uint height = 0;
            if (previousBlock != null)
                height = previousBlock.Height + 1;

            var block = new Block(
                id: Guid.NewGuid(),
                height: height,
                data: entry.Data,
                comment: entry.Comment,
                hash: [],
                timestamp: DateTime.Now,
                nonce: 0
            )
            {
                Previous = previousBlock
            };

            ulong iterations = 0;

            int tasksCount = Environment.ProcessorCount;
            ulong rangePerThread = ulong.MaxValue / (ulong)tasksCount; // Nonce range per task.
            var tasks = new Task[tasksCount];

            var rateStopwatch = Stopwatch.StartNew();

            // Create PoW tasks.
            // Every task checks its own nonce range.
            for (int i = 0; i < tasksCount; i++)
            {
                // Capture loop variable by value.
                // Without this, all tasks would share the same 'i' reference (closure issue).
                int j = i;

                tasks[i] = Task.Run(() =>
                {
                    Span<byte> hash = stackalloc byte[256];

                    ulong localNonce = (ulong)j * rangePerThread;
                    ulong endNonce = localNonce + rangePerThread;

                    while (localNonce < endNonce)
                    {
                        // Return 'null' if cancellation was requested.
                        if (entry.GenerationCancellationRequested)
                            return null;

                        // Return 'null' if the block was generated by other task.
                        if (block.Hash.Length != 0)
                            return block;

                        // Recalculate generation rate.
                        if (iterations % rateCalculationInterval == 0 && iterations != 0)
                        {
                            entry.HashesPerSecond = rateCalculationInterval / rateStopwatch.Elapsed.TotalSeconds;
                            rateStopwatch.Restart();
                        }

                        hash = block.GetHash(++localNonce);
                        if (IsHashValid(hash))
                        {
                            // If nonce value is correct, then
                            // lock block object, set its properties and return it.
                            lock (block)
                            {
                                block.Hash = hash.ToArray();
                                block.Nonce = localNonce;

                                return block;
                            }
                        }

                        iterations++;
                    }

                    return null; // Return 'null' if hash in given nonce range wasn't found.
                });
            }

            // Wait for all tasks.
            // When the correct nonce is found, the other tasks will stop by themselves.
            Task.WaitAll(tasks);

            // Return 'null' if the block hash wasn't found.
            if (block.Hash.Length == 0)
                return null;

            return block;
        }

        /// <summary>
        /// Reads next block from stream.
        /// </summary>
        /// <param name="stream">Stream to read from.</param>
        /// <param name="previousBlock">Previous block; pass <see langword="null"></see> if current block is genesis.</param>
        /// <returns>Read block; <see langword="null"></see> if no blocks was read.</returns>
        public static Block? FromStream(Stream stream, Block? previousBlock)
        {
            // ID
            byte[] buffer = new byte[16];
            int bytesRead = stream.Read(buffer);
            Guid id = new(buffer);

            // Return null, if there's end of stream
            if (bytesRead == 0)
                return null;

            // Height
            buffer = new byte[4];
            stream.Read(buffer);
            uint height = BitConverter.ToUInt32(buffer);

            // Hash
            byte[] hash = new byte[32];
            stream.Read(hash);

            // Previous hash
            byte[] previousHash = new byte[32];
            stream.Read(previousHash);

            // Timestamp
            buffer = new byte[8];
            stream.Read(buffer);
            DateTime timestamp = DateTime.FromBinary(BitConverter.ToInt64(buffer));

            // Nonce
            buffer = new byte[8];
            stream.Read(buffer);
            ulong nonce = BitConverter.ToUInt64(buffer);

            // Comment length
            buffer = new byte[4];
            stream.Read(buffer);
            uint commentLength = BitConverter.ToUInt32(buffer);

            // Comment
            buffer = new byte[commentLength];
            stream.Read(buffer);
            string comment = Encoding.UTF8.GetString(buffer);

            // Data length
            buffer = new byte[8];
            stream.Read(buffer);
            ulong dataLength = BitConverter.ToUInt64(buffer);

            // Data
            byte[] data = new byte[dataLength];
            stream.Read(data);

            return new Block(
                id,
                height,
                data,
                comment,
                hash,
                timestamp,
                nonce
            )
            {
                Previous = previousBlock
            };
        }

        /// <summary>
        /// Writes binary-serialized block data to <paramref name="stream"/>.
        /// </summary>
        /// <param name="stream">Stream to write.</param>
        public void WriteBlockToStream(Stream stream)
        {
            // ID
            stream.Write(Id.ToByteArray());

            // Height
            stream.Write(BitConverter.GetBytes(Height));

            // Hash
            stream.Write(Hash);

            // Previous hash
            byte[] previousHash = Enumerable.Repeat<byte>(0, 32).ToArray();
            if (Previous != null)
                previousHash = Previous.Hash;
            stream.Write(previousHash);

            // Timestamp
            stream.Write(BitConverter.GetBytes(Timestamp.ToBinary()));

            // Nonce
            stream.Write(BitConverter.GetBytes(Nonce));

            // Comment length
            byte[] commentBytes = Encoding.UTF8.GetBytes(Comment);
            stream.Write(BitConverter.GetBytes((uint)commentBytes.Length));

            // Comment
            stream.Write(commentBytes);

            // Comment length
            stream.Write(BitConverter.GetBytes((ulong)Data.LongLength));

            // Comment
            stream.Write(Data);
        }

        /// <summary>
        /// Returns <see langword="true"></see> if <paramref name="hash"/> less than target, otherwise <see langword="false"></see>.
        /// </summary>
        public static bool IsHashValid(ReadOnlySpan<byte> hash)
        {
            var target = GetHashTarget(26);

            Span<byte> positiveHash = stackalloc byte[hash.Length + 1];
            hash.CopyTo(positiveHash);

            var hashInt = new BigInteger(positiveHash);
            return hashInt < target;
        }

        /// <summary>
        /// Generates the target value for hash difficulty verification in the Proof of Work algorithm.
        /// The target is calculated as 2^(256 - <paramref name="bits"/>), where 256 is the hash length in bits.
        /// The higher the <paramref name="bits"/>, the lower the target and the higher the difficulty.
        /// </summary>
        public static BigInteger GetHashTarget(int bits)
        {
            BigInteger maxTarget = BigInteger.Pow(2, 256) - 1;
            return maxTarget >> bits;
        }

        /// <summary>
        /// Verifies the integrity of the block by recalculating its hash and comparing it to the stored hash.
        /// </summary>
        /// <returns><see langword="true"></see> if the block's hash is valid and matches the computed hash; otherwise, <see langword="false"></see>.</returns>
        public bool CheckForValidity()
        {
            Span<byte> feed = GetHashFeed();
            var hash = SHA256.HashData(feed);

            return hash.SequenceEqual(Hash);
        }

        /// <summary>
        /// Computes and returns block summary hash with specified <paramref name="nonce"/> value.
        /// </summary>
        private Span<byte> GetHash(ulong nonce)
        {
            Span<byte> feed = GetHashFeed(nonce);
            return SHA256.HashData(feed);
        }

        /// <summary>
        /// Computes and returns block summary hash.
        /// </summary>
        public Span<byte> GetHash() => GetHash(Nonce);

        /// <summary>
        /// Returns the concatenated block data for hashing with specified <paramref name="nonce"/> value.
        /// </summary>
        private Span<byte> GetHashFeed(ulong nonce)
        {
            var bytes = new List<byte>();

            // ID
            bytes.AddRange(Id.ToByteArray());

            // Height
            bytes.AddRange(BitConverter.GetBytes(Height));

            // Previous hash
            Span<byte> previousHash = Enumerable.Repeat<byte>(0, 32).ToArray();
            if (Previous != null)
                previousHash = Previous.Hash;
            bytes.AddRange(previousHash);

            // Timestamp
            bytes.AddRange(BitConverter.GetBytes(Timestamp.ToBinary()));
            
            // Nonce
            bytes.AddRange(BitConverter.GetBytes(nonce));

            // Comment
            bytes.AddRange(Encoding.UTF8.GetBytes(Comment));

            // Data
            bytes.AddRange(Data);

            return bytes.ToArray();
        }

        /// <summary>
        /// Returns the concatenated block data for hashing.
        /// </summary>
        public Span<byte> GetHashFeed() => GetHashFeed(Nonce);
    }
}
